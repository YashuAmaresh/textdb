/**
 * Implementation of a parser for the TextQL query language.
 * Please check README.md for grammar specification and usage.
 * The parser generates statements objects from the parsed data.
 * 
 * @author Flavio Bayer
 */

/**
 * JavaCC compilation options
 */
options {
	/**
	 * Multiple instances of the parser might be required, thus the parser
	 * should not be compiled as static (made up by static methods).
	 */
    STATIC = false;
    /**
     * Use Unicode Input since Java's implementation of String, Character and
     * console input uses unicode. Compiling without using UNICODE_INPUT might
     * lead to unexpected results if you are using the wrong encoding.
     * Please make sure to provide a source with unicode characters, wrapping
     * the input in a Java Reader such as FileReader or InputStreamReader
     * if necessary.
     */
    UNICODE_INPUT = true;
    /**
     * The TextQL language is case-insensitive.
     */
    IGNORE_CASE = true;
}

PARSER_BEGIN(TextQLParser)

package edu.uci.ics.textdb.textql.languageparser;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import org.apache.commons.lang3.builder.EqualsBuilder;

public class TextQLParser{
  
    /**
     * Statement class and subclasses (SelectStatement, CreateViewStatement)
     * Each Statement class has an id attribute. Statement subclasses have
     * specific fields related to their functions. These classes have no methods.
     * They are used only as containers to move data.
     * Statement --+ SelectStatement
     *             + CreateViewStatement
     */
    static public abstract class Statement {
        /**
         * The {@link String} Identifier of each Statement object
         */
        public String id;
        
        public Statement() {
            this(null);
        }
        public Statement(String id) {
            this.id = id;
        }
        @Override
        public boolean equals(Object other) {
            if (other == null) { return false; }
            if (other.getClass() != this.getClass()) { return false; }
            Statement statement = (Statement) other;
            return new EqualsBuilder()
                        .append(id, statement.id)
                        .isEquals();
        }
    }
    static public class SelectStatement extends Statement {
        /**
         * Set to true when '*' is used as the fields to be projected, as in "SELECT * FROM ..."
         */
        public Boolean projectAll;
        
        /**
         * The { @link List } of fields to be projected if it is specified as
         * in "SELECT a, b, c FROM ..."
         */
        public List<String> projectedFields;
        
        /**
         * Predicate used for data extraction such as keyword match in "KEYWORDMATCH(a,"word")"
         */
        public ExtractPredicate extractPredicate;

        /**
         * The identifier of a view or a table name, as in "SELECT... FROM viewName"
         * used as source of tuples
         */
        public String fromClause;

        /**
         * The maximum number of tuples to be returned, as in "SELECT...FROM... LIMIT 5"
         */
        public Integer limitClause;

        /**
         * The number of tuples to be skipped before returning, as in "SELECT...FROM... OFFSET 5"
         */
        public Integer offsetClause;

        public SelectStatement() {
            this(null, null, null, null, null, null, null);
        }
        public SelectStatement(String id, Boolean projectAll,
                              List<String> projectedFields, ExtractPredicate extractPredicate,
                              String fromClause, Integer limitClause, Integer offsetClause) {
            super(id);
            this.projectAll = projectAll;
            this.projectedFields = projectedFields;
            this.extractPredicate = extractPredicate;
            this.fromClause = fromClause;
            this.limitClause = limitClause;
            this.offsetClause = offsetClause;
        }
        @Override
        public boolean equals(Object other) {
            if (other == null) { return false; }
            if (other.getClass() != this.getClass()) { return false; }
            SelectStatement selectStatement = (SelectStatement) other;
            return new EqualsBuilder()
                        .appendSuper(super.equals(selectStatement))
                        .append(projectAll, selectStatement.projectAll)
                        .append(projectedFields, selectStatement.projectedFields)
                        .append(extractPredicate, selectStatement.extractPredicate)
                        .append(fromClause, selectStatement.fromClause)
                        .append(limitClause, selectStatement.limitClause)
                        .append(offsetClause, selectStatement.offsetClause)
                        .isEquals();
        }
    }
    static public class CreateViewStatement extends Statement {
        /**
         * The { @link Statement } for which the create view statement creates an alias,
         * e.g., in "CREATE VIEW v AS SELECT *FROM t; the view with id 'v' will have the
         * select statement "SELECT * FROM t" as subStatement (in a SelectStatement object)
         */
        public Statement subStatement;
        
        public CreateViewStatement() {
            this(null, null);
        }
        public CreateViewStatement(String id, Statement subStatement) {
            super(id);
            this.subStatement = subStatement;
        }
        @Override
        public boolean equals(Object other) {
            if (other == null) { return false; }
            if (other.getClass() != this.getClass()) { return false; }
            CreateViewStatement createViweClass = (CreateViewStatement) other;
            return new EqualsBuilder()
                        .appendSuper(super.equals(createViweClass))
                        .append(subStatement, createViweClass.subStatement)
                        .isEquals();
        }
    }

    /**
     * ExtractPredicate class and its subclasses such as KeywordExtractPredicate.
     * Subclasses have specific fields related to its extraction functionalities.
     * These classes have no methods. They are used only as containers.
     * ExtractPredicate --+ KeywordExtractPredicate
     */
    static public abstract class ExtractPredicate {
        @Override
        public boolean equals(Object other) {
	        if (other == null) { return false; }
	        if (other.getClass() != getClass()) { return false; }
	        //since ExtractPredicate has no attributes, there's nothing to compare but the class itself
	        return true;
        }
    }
    static public class KeywordExtractPredicate extends ExtractPredicate {
        /**
         * The { @link List } of fields on which the keyword search should be performed
         */
        public List<String> matchingFields;
        
        /**
         * The keyword(s) used for a keyword search
         */
        public String keywords;
        
        /**
         * The type of matching to be performed during the keyword search
         */ 
        public String matchingType;
    
        public KeywordExtractPredicate() {
          this(null, null, null);
        }
        public KeywordExtractPredicate(List<String> matchingFields, String keywords, String matchingType) {
            this.matchingFields = matchingFields;
            this.keywords = keywords;
            this.matchingType = matchingType;
        }
        @Override
        public boolean equals(Object other) {
            if (other == null) { return false; }
            if (other.getClass() != getClass()) { return false; }
            KeywordExtractPredicate keywordExtractPredicate = (KeywordExtractPredicate) other;
            return new EqualsBuilder()
                    .appendSuper(super.equals(keywordExtractPredicate))
                    .append(matchingFields, keywordExtractPredicate.matchingFields)
                    .append(keywords, keywordExtractPredicate.keywords)
                    .append(matchingType, keywordExtractPredicate.matchingType)
                    .isEquals();
        }
    }

    /**
     * Generate a unique deterministic sequence of IDs for new statements.
     * The id follows the format "_sidX", where X is an incremental hexadecimal
     * integer without padding starting from 0.
     * e.g., "_lid0", "_lid1", ..., "_lid9", "_lida", ..., "_lidf", "_lid10", ...
     * @return The generated id
     */
    private int currentStatementIdSequence = 0;
    private String getNewStatementId(){
        return "_sid" + Integer.toString(currentStatementIdSequence++, 16);
    }
}

PARSER_END(TextQLParser)


/*
 * Skipped Tokens
 * The following are tokens that should be ignored/skipped.
 */
SKIP : { " " | "\n" | "\r" | "\t" | "\f" }
/**
 * Basic Tokens - Reserved Words
 */
TOKEN : { < CREATE : "CREATE" > }
TOKEN : { < DIRECTORY : "DIRECTORY" > }
TOKEN : { < VIEW : "VIEW" > }
TOKEN : { < SELECT : "SELECT" > }
TOKEN : { < EXTRACT : "EXTRACT" > }
TOKEN : { < FROM : "FROM" > }
TOKEN : { < AS : "AS" > }
TOKEN : { < LIMIT : "LIMIT" > }
TOKEN : { < OFFSET : "OFFSET" > }
TOKEN : { < JOIN : "JOIN" > }
TOKEN : { < WHERE : "WHERE" > }
TOKEN : { < OUTPUT : "OUTPUT" > }
TOKEN : { < INSERT : "INSERT" > }
TOKEN : { < INTO : "INTO" > }
TOKEN : { < VALUES : "VALUES" > }
TOKEN : { < KEYWORDMATCH : "KEYWORDMATCH" > }
/**
 *    Basic Tokens - Comparison operators
 */
TOKEN : { < ASSIGN: "="> }
TOKEN : { < LT: "<" > }
TOKEN : { < GT: ">" > }
TOKEN : { < EQ: "==" > }
TOKEN : { < LE: "<=" > }
TOKEN : { < GE: ">=" > }
TOKEN : { < NE: "!=" > }
/**
 * Basic Tokens - Other 1-Character tokens
 */
TOKEN : { < LPAREN: "(" > }
TOKEN : { < RPAREN: ")" > }
TOKEN : { < LBRACE: "{" > }
TOKEN : { < RBRACE: "}" > }
TOKEN : { < LBRACKET: "[" > }
TOKEN : { < RBRACKET: "]" > }
TOKEN : { < SEMICOLON: ";" > }
TOKEN : { < COMMA: "," > }
TOKEN : { < DOT: "." > }
TOKEN : { < STAR : "*" > }


/*
 * Literal Tokens
 */
/**
 *    NUMBER_LITERAL - Matches a number in decimal format.
 *  The matched token consists of an optional ('-') character followed by
 *  (d [ . [d]]) or ('.' d), where d is a digit string, and the bracket content
 *  is optional.
 *  The following are matching examples
 *      0
 *      -0
 *      12
 *      123.
 *      -78.90
 *      -.789
 */

TOKEN : { < NUMBER_LITERAL : ("-")? ((["0"-"9"])+ ("." (["0"-"9"])*)? | "." (["0"-"9"])+) > }
/**
 *    STRING_LITERAL - Matches a quoted string (it may contain escaped quotes).
 *  The matched token consists of a quote ('"') followed by any character except
 *  for another quote('"'), unless it is escaped('\"') and ended with a quote('"').
 *  The following are matching examples
 *      ""
 *      "abc"
 *      "de f"
 *      "de\" f"
 *      "d\"e\"f"
 *      "de\n f"
 *      "de\\ f"
 */    
TOKEN : { < STRING_LITERAL : "\"" ( "\\" ~[] | ~["\""] )* "\"" > }

/**
 *    REGEX_LITERAL - Matches a regex string delimited by forward slashes
 *                  (it may contain escaped forward slashes)
 *  The matched token consists of a forward slash ('/') followed by any
 *  character except for another forward slash ('/'), unless it is escaped ('\/')
 *  and ended with a forward slash ('/').
 *  The following are matching examples
 *      //
 *      /abc/
 *      /de f/
 *      /d\/e/
 *      /d\n/
 *      /d\/e\/f/
 *      /"/
 */   
TOKEN : { < REGEX_LITERAL : "/" ( "\\" ~[] | ~["/"] )* "/" > }

/**
 *    IDENTIFIER_LITERAL - Matches an identifier string(e.g., for variable names).
 *  The token matched is composed by an alphabetic character followed by
 *  alphanumeric characters.
 *  The following are matching examples
 *      i
 *      id
 *      id0
 *      i0d
 */ 
TOKEN : { < IDENTIFIER_LITERAL : ["a"-"z"](["a"-"z","0"-"9"])*  > }


/*
 * Wrappers for literal tokens
 * Those are simple methods that convert raw Tokens into formated data
 */
/**
 * Consume a NUMBER_LITERAL from the input and convert it to a String.
 * Examples of valid input: 0, -0, 12, 123., -78.90, -.789
 * @return The String representation of the NUMBER_LITERAL
 */
String numberLiteralToString():
{
    Token token;
}
{
    token = <NUMBER_LITERAL>
    {
        // return the matched string
        return token.image;
    }
}
/**
 * Consume a NUMBER_LITERAL from the input and convert it to a Double.
 * Examples of valid input: 0, -0, 12, 123., -78.90, -.789
 * @throws NumberFormatException if the conversion to Double fails
 * @return The double representation of the NUMBER_LITERAL
 */
double numberLiteralToDouble():
{
    String numberString;
}
{
    numberString = numberLiteralToString()
    {
        // return the matched string converted to double
        return Double.parseDouble(numberString);
    }
}
/**
 * Consume a NUMBER_LITERAL from the input and convert it to an Integer.
 * Examples of valid input: 0, -0, 12
 * @throws NumberFormatException if the conversion to Integer fails
 * @return The integer representation of the NUMBER_LITERAL
 */
int numberLiteralToInteger():
{
    String numberString;
}
{
    numberString = numberLiteralToString()
    {
        // return the matched string converted to integer
        return Integer.parseInt(numberString);
    }
}
/**
 * Consume a STRING_LITERAL from the input and convert it to String.
 * Escaped quotes and delimiter quotes are removed.
 * Examples of REGEX_LITERAL and the output String(without delimiter simple-quotes):
 *      ""        = > '' (empty)
 *      "abc"     = > 'abc'
 *      "de f"    = > 'de f'
 *      "de\" f"  = > 'de" f'
 *      "d\"e\"f" = > 'd"e"f'
 *      "de\n f"  = > 'de\n f'
 *      "de\\f"   = > 'de\\f'
 * @return The String representation of the STRING_LITERAL
 */
String stringLiteralToString():
{
    Token token;
}
{
    token = <STRING_LITERAL>
    {
        // get the matching string
        String string = token.image; 
        // remove delimiter quotes
        String unquotedString = string.substring(1, string.length()-1);
        // convert escaped quotes
        String escapedUnquotedString = unquotedString.replace("\\\"", "\"");
        // return the computed string
        return escapedUnquotedString;
    }
}
/**
 * Consume a REGEX_LITERAL from the input and convert it to String.
 * Escaped slashes and delimiter slashes are removed.
 * Examples of REGEX_LITERAL and the output String(without delimiter quotes):
 *      //         = > "" (empty)
 *      /abc/      = > "abc"
 *      /de f/     = > "de f"
 *      /d\/e/     = > "d/e"
 *      /d\n/      = > "d\n"
 *      /d\/e\/f/  = > "d/e/f"
 *      /"/        = > "\"" (a quote)
 * @return The String representation of the REGEX_LITERAL
 */
String regexLiteralToString():
{
    Token token;
}
{
    token = <REGEX_LITERAL>
    {
        // get the matching string
        String regex = token.image;
        // remove delimiter slashes
        String unslashedRegex = regex.substring(1, regex.length()-1); 
        // convert escaped slashes
        String escapedUnslashedRegex = unslashedRegex.replace("\\/", "/");
        // return the computed string
        return escapedUnslashedRegex;
    }
}
/**
 * Consume an IDENTIFIER_LITERAL from input and convert it to String.
 * Examples: i, id, id0, i0d
 * @return The String representation of the IDENTIFIER_LITERAL
 */
String identifierLiteralToString():
{
    Token token;
}
{
    token = <IDENTIFIER_LITERAL>
    {
        // return the matched string
        return token.image;
    }
}

/*
 *    List of literal tokens separated by commas
 */
/**
 * Consume a list of IDENTIFIER_LITERAL (one or more) from input and convert it to List<String>.
 * Example: "i,id,id0,i0d" (without quote) = > { "i", "id", "id0", "i0d" }
 * Grammar: <IdentifierLiteral> ("," <IdentifierLiteral>)* 
 * @return The List<String> representation of the list of IDENTIFIER_LITERAL
 */
List<String> identifierListToListString():
{
    String identifier;
    List<String> identifiers = new ArrayList<String>();
}
{
    identifier = identifierLiteralToString() { identifiers.add(identifier); } 
    (
        <COMMA> identifier = identifierLiteralToString() { identifiers.add(identifier); }
    )*
    {
        return identifiers;
    }
}


/*
 * Parse declaration of Statements
 */
/**
 * Consume the whole input and generate a list containing the declared statements.
 * Grammar: ( <Statement> )* <EOF>
 * @param statementConsumer The consumer is called after each statement is parsed
 * @return The list of statements of the whole input
 */
List<Statement> mainStatementList(Consumer<Statement> statementConsumer) : 
{
    List<Statement> statements = new ArrayList();
    Statement newStatement;
}
{
    // look for zero or more occurrences of Statement
    (
        // parse one statement
        newStatement = statement() { statements.add(newStatement); } 
        {
            // call the statement consumer (if we have one) after each statement is parsed
            if(statementConsumer!=null) { 
                statementConsumer.accept(newStatement);
            }
        }
    )*
    // consume the End Of File
    <EOF>
    // return the list of statements generated
    {
        return statements;
    }
}

/**
 * Consume one statement declaration from the input and generate a Statement
 * object with the parsed data. The type of statement can be either
 * SelectStatement or CreateViewStatement
 * Grammar: ( <SelectStatement> | <CreateViewStatement> ) ";"
 * @return The Statement representation of the next statement declaration
 */
Statement statement() : 
{
    Statement newStatement;
}
{
    // parse one of the types of statement
    (
            newStatement = selectStatement() 
        |
            newStatement = createViewStatement()
    )
    <SEMICOLON>
    // return generated Statement
    {
        return newStatement;
    }
}

/**
 * Consume a "CREATE VIEW" statement declaration from the input and generate a
 * CreateViewStatement object with the parsed data.
 * Examples of valid input:
 *         CREATE VIEW viewname0 AS <SelectStatement>
 * Grammar: "CREATE" "VIEW" <Identifier>
 *          "AS" ( <SelectStatement> )
 * @return The CreateViewStatement representation of the statement declaration
 */
CreateViewStatement createViewStatement() : 
{
    CreateViewStatement createViewStatement = new CreateViewStatement();
    Statement subStatement;
    String viewName;
}
{
    // parse CREATE VIEW viewName AS
    <CREATE>
    <VIEW>
    viewName = identifierLiteralToString() { createViewStatement.id = viewName; }
    <AS>
    // parse the inner statement (subStatement) which is a SelectStatement
    (
        subStatement = selectStatement()
    ){ createViewStatement.subStatement = subStatement; }
    // return generated CreateViewStatement
    {
        return createViewStatement;
    }
}

/**
 * Parse a select statement declaration from the input and generate a
 * SelectStatement object with the parsed data.
 * Examples of valid input:
 *         SELECT * FROM t
 *         SELECT a, b, c FROM t LIMIT 1 OFFSET 8
 *         EXTRACT KEYWORDMATCH(g0, "key1") FROM k
 *         SELECT a EXTRACT KEYWORDMATCH(field, "key1") FROM k
 *         SELECT * EXTRACT KEYWORDMATCH([h6,h7,k8,k9], "key1", conjunction) FROM k LIMIT 1 OFFSET 8
 * Grammar: (
 *              "SELECT" ( "*" | <identifierListToListString> ) ( "EXTRACT" <ExtractPredicate> )?
 *            |
 *              "EXTRACT" <ExtractPredicate>
 *          )
 *          "FROM" <Identifier>
 *          ("LIMIT" <Number> )?
 *          ("OFFSET" <Number> )?
 * @return The SelectStatement representation of the statement declaration
 */  
SelectStatement selectStatement() : 
{
    SelectStatement selectStatement = new SelectStatement();
    selectStatement.id = getNewStatementId();
    List<String> identifiers;
    String fromClause;
    Integer limitClause;
    Integer offsetClause;
    ExtractPredicate extractPredicate;
}
{
    // parse the SELECT clause or/and the EXTRACT clause
    (
            // parse the SELECT clause only, or parse the SELECT clause and the EXTRACT clause
            (
                // parse the SELECT clause
                <SELECT> 
                ( 
                        <STAR> { selectStatement.projectAll = true; } // SELECT *
                    | 
                        identifiers = identifierListToListString() // SELECT a,b,...
                            { selectStatement.projectedFields = identifiers; } 
                )
                // parse the EXTRACT clause (optional)
                (
                    <EXTRACT> extractPredicate = extractPredicate() // EXTRACT extractPredicate
                        { selectStatement.extractPredicate = extractPredicate; } 
                )?
            )
        |
            // parse the EXTRACT clause only
            <EXTRACT> extractPredicate = extractPredicate() // EXTRACT only
                { selectStatement.extractPredicate = extractPredicate; } 
    )
    // parse FROM field
    <FROM> fromClause = identifierLiteralToString()
        { selectStatement.fromClause = fromClause; }
    // parse LIMIT field(optional)
    (
      <LIMIT> limitClause = numberLiteralToInteger()
        { selectStatement.limitClause = limitClause; }
    )?
    // parse OFFSET field(optional)
    (
      <OFFSET> offsetClause = numberLiteralToInteger()
        { selectStatement.offsetClause = offsetClause; }
    )?
    // return generated SelectStatement
    {
        return selectStatement;
    }
}


/*
 * Parse declaration of Predicates
 */
/**
 * Parse one extract predicate from the input and generate an ExtractPredicate
 * object with the parsed data.
 * The type of extract predicate can be only KeywordExtractPredicate.
 * Grammar: ExtractPredicate := ( <KeywordExtractPredicate> )
 * @return The ExtractPredicate representation of the next extract predicate
 */
ExtractPredicate extractPredicate() : 
{
    ExtractPredicate extractPredicate;
}
{
    // parse one type of extract predicate
    (
        extractPredicate = extractKeywordMatchPredicate()
    )
    // return generated KeywordExtractPredicate
    {
        return extractPredicate;
    }
}

/**
 * Parse a keyword extract predicate from the input and generate a
 * KeywordExtractPredicate object with the parsed data.
 * Examples of valid input:
 *         KEYWORDMATCH(field0, "keywords")
 *         KEYWORDMATCH([f1,g2,h4,i9], "new york")
 *         KEYWORDMATCH(g3, "keyword", substring)
 * Grammar: "KEYWORDMATCH("
 *            ( <Identifier> | "[" <identifierList> "]" )
 *            "," <String>
 *            ( "," <Identifier> )?
 *          ")"
 * @return The KeywordExtractPredicate representation of the next statement declaration
 */
KeywordExtractPredicate extractKeywordMatchPredicate() : 
{
    KeywordExtractPredicate keywordExtractPredicate = new KeywordExtractPredicate();
    List<String> matchingFields;
    String matchingField;
    String keywords;
    String matchingType;
}
{
    <KEYWORDMATCH>
    <LPAREN>
        // parse the matching fields (either a field or a list of fields)
        (
                // parse only one field identifier
                matchingField = identifierLiteralToString() { matchingFields = Arrays.asList(matchingField); }
            | 
                // parse the list of fields between brackets
                <LBRACKET> matchingFields = identifierListToListString() <RBRACKET>
        ) { keywordExtractPredicate.matchingFields = matchingFields; }
        // parse the keywords as a string
        <COMMA> keywords = stringLiteralToString() { keywordExtractPredicate.keywords = keywords; }
        // parse the matching type as an identifier (optional)
        (
            <COMMA> matchingType = identifierLiteralToString() { keywordExtractPredicate.matchingType = matchingType; }
        )?
    <RPAREN>
    // return generated KeywordExtractPredicate
    {
        return keywordExtractPredicate;
    }
}